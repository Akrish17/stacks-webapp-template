---
id: publishing
title: Publishing Packages
sidebar_label: Publishing Packages
---

<AUTOGENERATED_TABLE_OF_CONTENTS>

## Our Packages

`stacks-webapp-template` is a [monorepo](./monorepo.md), meaning it is divided into independent sub-packages.

These packages can be found in the packages/ directory:

```
packages/
  elint-config/
  template-cli/
```

## Package Registry

All our packages are publically available from `npm`: https://www.npmjs.com/org/amidostacks


## Package Management

We are following in the footsteps of [create-react-app](https://github.com/facebook/create-react-app) and using [Lerna](https://lernajs.io) which can be installed using [npm](https://www.npmjs.com/package/lerna).

Lerna is configured to publish all changes in [packages](../packages) once any changes have passed the pipeline gates as defined in [build/azDevOps/azure](build/azDevOps/azure/). Note that it's then up the consumers of the packages to update their versions as needed.

## Automated Package Publishing

Lerna is embedded as a step in the [monorepo](./monorepo.md) pipeline. Check out the pipeline step [publish-packages-lerna.yml](./build/azDevOps/azure/templates/steps/publish-packages-lerna.yml) for more informatiion on how this is done.

This automates the following process:

1. changes are merged to master
2. this triggers lerna to look for changes in the [packages](./packages.md)
3. if changes are found, verisons are bumped, CHANGELOGs created, and the commit is tagged as a release in Github
4. the packages are published to the configured registry

### Why have we automated this?

We think it's good practice to test changes before publishing it to our [public npm registry](https://www.npmjs.com/settings/amidostacks/packages). so you know it's free of errors

## Versioning

We are versioning as a seperate script in order to support publishing from a CI pipeline, and to automate the creation of changelogs based on the commit history. This is to ensure we don't rely on contributors publishing from local.

From root, run: `npm run version`

### What does `version` do?

1. Identifies packages that have been updated since the previous tagged release.
2. Bumps the version based on the Conventional Commits Specification
3. Updates CHANGELOG.md and updates the package.json if needed
4. Commits those changes and tags the commit.
5. Pushes to the git remote.

### Why do we use `lerna version --conventional-commits`?

>When run with this flag, lerna version will use the Conventional Commits Specification to determine the version bump and generate CHANGELOG.md files. [2]
[2]: https://github.com/lerna/lerna/tree/master/commands/version#--conventional-commits

### Why do we use `lerna publish from-package`?

1. We reduce risk of Git conflicts;
2. Lerna will need to commiting the `gitHead` SHA to the package.json of the package;
3. If a publish fails, then it will try again.

## Conventional Commits

We generate our CHANGELOGS.md automagically based on the `git commit`. The commit itself communicates the **WHAT**, whereas commit message communicates the **WHY**.

### What is a commit?

[`git commit`](https://git-scm.com/docs/git-commit) is a git command that is used to record your changes to the local repository.

### Why are we using Conventional Commits?

* Automatically generating CHANGELOGs.
* Automatically determining a semantic version bump (based on the types of commits landed).
* Communicating the nature of changes to teammates, the public, and other stakeholders.
* Triggering publish processes.
* Making it easier for people to contribute to your projects, by allowing them to explore a more structured commit history.

_Source: https://www.conventionalcommits.org/en/v1.0.0/#why-use-conventional-commits_

### How do we enforce Conventional Commits?

We use precommit hooks with [Husky](https://github.com/typicode/husky) and [commitlint](https://github.com/conventional-changelog/commitlint).

### What are the commit conventions format?

`type(scope?): subject`

Where:

* [`'type'=`](https://github.com/conventional-changelog/commitlint/tree/master/%40commitlint/config-conventional#type-enum)
  ```js
  [
    'build',
    'ci',
    'chore',
    'docs',
    'feat',
    'fix',
    'perf',
    'refactor',
    'revert',
    'style',
    'test'
  ];
  ```
* `scope?=` optional, addresses the specific area of change, or feature
* `subject=` why you are making the commit in the first place

Examples:
`chore: to run tests on travis ci`

`fix(server): to send cors headers`

`feat(blog): to add comment section`

## Publishing

From root, run: `npm run publish`

### What does `publish` do?

1. Publish packages tagged in the current commit (from-package).

*Lerna will never publish packages which are marked as private ("private": true in the package.json).*

### What happens in CI?

In order to Lerna to bump the version for the packages, we must ensure the following:

1. We are not in detached HEAD for the current commit SHA on master *(`git status --porcelain` is true)*
2. We ONLY publish packages from `master` once changes are merged into `master` and have passed all tests and reviews

### Why do we use `lerna publish from-package`?

> keyword except the list of packages to publish is determined by inspecting each `package.json` and determining if any package version is not present in the registry. Any versions not present in the registry will be published. This is useful when a previous lerna publish failed to publish all packages to the registry. [1]

[1]: https://github.com/lerna/lerna/tree/master/commands/publish#bump-from-package
